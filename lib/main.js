// Generated by CoffeeScript 2.2.3
  /**
  * Database helpers to provide easy database access.
  *
  * Usage:
  * db = require(thismodule)
  * db.initialize(function(){
  * 	db.dbname.createCollection(...)
  *	 	db.dbname.collectionname.find(...)
  * })
   */
var DB, MongoClient, Seq, _, assert, dbperf, logger, mongodb, util,
  indexOf = [].indexOf;

_ = require('underscore');

mongodb = require('mongodb');

assert = require('assert');

util = require('util');

Seq = require('seq');

logger = console;

dbperf = {};

MongoClient = class MongoClient {
  constructor(dbname, host, port, auth, _options) {
    var password, user;
    this._options = _options;
    if (!dbname) {
      throw new Error('A database name must be provided to create a new db client');
    }
    logger.debug(`Initializing MongoDb server ${this._host}:${this._port} with options`, this._options);
    if ((auth != null ? auth.user : void 0) && auth.password && auth.database) {
      user = encodeURIComponent(auth.user);
      password = encodeURIComponent(auth.password);
      this._connectUrl = `mongodb://${user}:${password}@${host}:${port}/${dbname}?authSource=${auth.database}`;
      logger.debug(`Created client for the '${dbname}' db, authenticated as ${auth.user} (from db ${auth.database}).`);
    } else {
      this._connectUrl = `mongodb://${host}:${port}/${dbname}`;
      logger.debug(`Created client for the '${dbname}' db (no authentication info provided).`);
    }
  }

  close() {
    return this.db.close();
  }

  shortCollectionName(raw) {
    return raw.split('.').pop();
  }

  addCollections(cols, indexesDef) {
    var col, ensureIndexCallback, i, indexDef, len, name, results;
    this.collections = {};
    logger.debug(util.format("indexesDef at %j", indexesDef));
    results = [];
    for (i = 0, len = cols.length; i < len; i++) {
      col = cols[i];
      name = col.collectionName;
      if (name.substr(0, 6) !== 'system') {
        if (this.collections[name] === void 0) {
          this.collections[name] = col;
          logger.debug(`OK looking at indexes for collection ${name}`);
          if (indexesDef[name] !== void 0) {
            results.push((function() {
              var j, len1, ref, results1;
              ref = indexesDef[name];
              results1 = [];
              for (j = 0, len1 = ref.length; j < len1; j++) {
                indexDef = ref[j];
                ensureIndexCallback = function(name) {
                  return function(err, indexName) {
                    if (err) {
                      return logger.error("ensureIndex", err);
                    } else {
                      return logger.debug(util.format(`Collection ${name} has index named ${indexName}`));
                    }
                  };
                };
                results1.push(col.ensureIndex(indexDef, {
                  background: true
                }, ensureIndexCallback(name)));
              }
              return results1;
            })());
          } else {
            results.push(void 0);
          }
        } else {
          throw Error('Can\'t override existing member ' + name);
        }
      } else {
        results.push(void 0);
      }
    }
    return results;
  }

  getAdmin() {
    return this.db.admin();
  }

  getCollections() {
    return this.collections;
  }

  initialize(params, fn) {
    var client, connectUrl, names;
    names = _.keys(params);
    connectUrl = this._connectUrl;
    client = this;
    logger.info(`MongoClient.init: initializing ${names}`);
    return Seq().seq(function() {
      var Client;
      Client = mongodb.MongoClient;
      return Client.connect(connectUrl, {
        db: {
          w: 1
        },
        server: client._options
      }, this);
    }).seq(function(mongoClient) {
      client.db = mongoClient.db();
      return client.db.collections(this);
    }).seq(function(cols) {
      var existing, missing;
      client.addCollections(cols, params);
      existing = _.pluck(cols, 'collectionName');
      logger.debug(`MongoClient.init: existing collections '${existing}'`);
      missing = _.difference(names, existing);
      if (missing.length > 0) {
        logger.info(`MongoClient.init: missing collections ${missing}`);
      }
      return this(null, missing);
    }).flatten().parMap(function(name) {
      logger.info(`Creating missing collection '${name}'`);
      return client.db.createCollection(name, this);
    }).unflatten().seq(function(cols) {
      if (cols.length > 0) {
        logger.info(`MongoClient.init: still missing collections ${_.pluck(cols, 'collectionName')}`);
        client.addCollections(cols, params);
      }
      return fn(null, this);
    }).catch(function(boo) {
      logger.error(`MongoClient.initialize ${boo}`);
      return fn(boo);
    });
  }

};

/*
* Connects the sysdb, local and shared databases to their respective databases
* and makes the collections available via thismodule.db.collectionname
* signature: params, [logger], [fn]
*		host: 127.0.0.1
* 	port: 3002
*		databases:
*			dbname1:
*				collection1: [<list of indexes>]
*				collection2: []
*			dbname2:
*				collection: []
* etc..
 */
DB = class DB {
  initialize(params1, lgger, fn) {
    var databases, db, dbnames;
    this.params = params1;
    if (fn === void 0 && (lgger != null ? lgger.log : void 0) === void 0) {
      fn = lgger;
    } else if (lgger !== void 0) {
      logger = lgger;
    }
    this._linkingInitiated = {};
    this.databases = {};
    databases = this.databases;
    db = this;
    dbnames = _.keys(typeof params !== "undefined" && params !== null ? params.databases : void 0);
    logger.debug(`MongoDB initializing databases ${dbnames}`);
    return Seq(dbnames).flatten().seqEach(function(dbname) {
      return db.addDatabase(dbname, params.databases[dbname], this);
    }).seq(function() {
      return typeof fn === "function" ? fn() : void 0;
    }).catch(function(err) {
      return typeof fn === "function" ? fn(err) : void 0;
    });
  }

  close(delay = 1000) {
    var db;
    db = this;
    return Seq().seq(function() {
      return setTimeout(this, delay);
    }).seq(function() {
      return this(null, _(db.databases).values);
    }).flatten().seqEach(function(client) {
      return client.close(this);
    }).catch(function(err) {
      if (err) {
        return logger.error(err.stack);
      }
    });
  }

  /* 
  * Links a database (a.k.a makes the database available via db[dbname], or db.databases[dbname]), and creates it if necessary with all specified collections and indexes
  * 
  * signature: dbname, [collectionsDef], [fn]
  * collectionsDef is a plain object, e.g
  * 	collection1: [<list of indexes>]
  * 	collection1: [<list of indexes>]
  * 	etc..
  * 

   */
  addDatabase(dbname, collectionsDef, fn) {
    var db;
    if (fn === void 0) {
      if (_.isFunction(collectionsDef)) {
        fn = collectionsDef;
        collectionsDef = {};
      }
    }
    db = this;
    return Seq().seq(function() {
      return db.linkDatabase(dbname, collectionsDef, this);
    }).seq(function() {
      var collectionName, collectionNames, collections, i, intersect, len;
      collections = db.databases[dbname].getCollections();
      collectionNames = _.keys(collections);
      intersect = _.intersection(collectionNames, _.keys(db));
      for (i = 0, len = collectionNames.length; i < len; i++) {
        collectionName = collectionNames[i];
        db.databases[dbname][collectionName] = collections[collectionName];
        if (indexOf.call(intersect, collectionName) >= 0) {
          logger.warn(`Conflicting collections name(s), db.${collectionName} shortcut unavailable, use db.databases.${dbname}.${collectionName}`);
        } else {
          logger.info(`OK  db.${collectionName} is a valid shortcut for db.databases.${dbname}.${collectionName}`);
          db[collectionName] = db.databases[dbname][collectionName];
        }
      }
      return typeof fn === "function" ? fn() : void 0;
    }).catch(function(boo) {
      return typeof fn === "function" ? fn(boo) : void 0;
    });
  }

  /*
  * Links a database (a.k.a makes the database available via db[dbname] if it already exists
   */
  linkDatabaseIfExists(dbname, fn) {
    var db, ref;
    db = this;
    logger.debug(`OK linkDatabaseIfExists ${dbname}`);
    if (((ref = db.databases[dbname]) != null ? ref.collections : void 0) !== void 0) {
      logger.debug(`OK database '${dbname}' is already linked`);
      return typeof fn === "function" ? fn() : void 0;
    } else if (_.keys(db.databases).length === 0 && dontCreate) {
      return typeof fn === "function" ? fn(new Error("MacMongo can't get an admin (no existing db to get an admin instance off of)")) : void 0;
    } else {
      if (this._linkingInitiated[dbname]) {
        return setTimeout(fn, 500); // linking is in progress, just wait for a bit
      } else {
        this._linkingInitiated[dbname] = true;
        return Seq().seq(function() {
          var firstDb;
          firstDb = db.databases[_.keys(db.databases)[0]];
          return firstDb.getAdmin().listDatabases(this);
        }).seq(function(dbs) {
          var dbnames, ref1;
          dbnames = _.pluck(dbs.databases, "name");
          if (ref1 = dbname.toLowerCase(), indexOf.call(dbnames, ref1) < 0) {
            return typeof fn === "function" ? fn(new Error(`${dbname.toLowerCase()} not found amongst collections of ${dbname} (${dbnames})`)) : void 0;
          }
          return db.linkDatabase(dbname, this);
        }).seq(function() {
          return typeof fn === "function" ? fn() : void 0;
        }).catch(function(boo) {
          return typeof fn === "function" ? fn(boo) : void 0;
        });
      }
    }
  }

  /*
  * Links a database (a.k.a makes the database available via db[dbname], or db.databases[dbname]), and creates it it doesn't already exists
   */
  linkDatabase(dbname, collectionsDef, fn) {
    var db;
    if (fn === void 0) {
      if (_.isFunction(collectionsDef)) {
        fn = collectionsDef;
        collectionsDef = {};
      }
    }
    db = this;
    if (db.databases[dbname] !== void 0) {
      logger.debug(`OK database '${dbname}' is already linked`);
      return typeof fn === "function" ? fn() : void 0;
    }
    return Seq().seq(function() {
      db.databases[dbname] = new MongoClient(dbname, db.params.host, db.params.port, db.params.auth, db.params.options);
      if (indexOf.call(_.keys(db), dbname) >= 0) {
        logger.error(`Conflicting database name, db.${dbname} shortcut is unavailable, use db.databases.${dbname}`);
      } else {
        db[dbname] = db.databases[dbname];
      }
      return db.databases[dbname].initialize(collectionsDef, this);
    }).seq(function() {
      return typeof fn === "function" ? fn() : void 0;
    }).catch(function(boo) {
      return typeof fn === "function" ? fn(boo) : void 0;
    });
  }

  /**
  * A utility method to generate GUIDs on the fly
   */
  uid() {
    var n, ui, uid;
    n = 4;
    uid = (function() {
      var results;
      results = [];
      while (n -= 1) {
        results.push((Math.abs((Math.random() * 0xFFFFFFF) | 0)).toString(16));
      }
      return results;
    })();
    ui = uid.join('');
    return ui;
  }

  /**
  * Utility methods to escape dots from attribute names
   */
  escapeDot(str) {
    return str.replace(/\./g, "#dot;");
  }

  unescapeDot(o) {
    var p, res;
    res = {};
    if (_.isObject(o) && !_.isArray(o) && !_.isDate(o)) {
      for (p in o) {
        if (o.hasOwnProperty(p)) {
          res[p.replace(/#dot;/g, ".")] = db.unescapeDot(o[p]);
        }
      }
    } else {
      res = o;
    }
    return res;
  }

  getCollectionNames(dbname) {
    var collections, database, name, ref;
    collections = [];
    if (dbname === void 0) {
      ref = this.databases;
      for (name in ref) {
        database = ref[name];
        logger.info(`${database} has ${_.keys(database.getCollections())}`);
        collections = collections.concat(_.keys(database.getCollections()));
      }
    } else {
      collections = _.keys(this.databases[dbname].getCollections());
    }
    return collections;
  }

  getLayout() {
    var collection, colname, database, dbname, layout, ref, ref1;
    layout = {};
    ref = this.databases;
    for (dbname in ref) {
      database = ref[dbname];
      if (layout[dbname] === void 0) {
        layout[dbname] = [];
      }
      ref1 = database.getCollections();
      for (colname in ref1) {
        collection = ref1[colname];
        layout[dbname].push(colname);
      }
    }
    return layout;
  }

  /**
  * Logs db performance & explain
   */
  perfLog(cursor) {
    return cursor.explain(function(err, doc) {
      var agg, collectionName, stats;
      if (err) {
        console.error('db.perf', err);
      }
      if (doc) {
        collectionName = cursor.collection.collectionName;
        if (doc.millis > 300) {
          logger.warn(`db.perf.${collectionName}`, `Latency ${doc.millis}ms: ${doc.n} records returned, ${doc.nscanned} scanned`);
          logger.warn('db.perf.query', cursor.selector);
          logger.warn('db.perf.explain', doc);
        } else {
          logger.debug(`db.perf.${collectionName}`, `${doc.nscanned} records scanned, ${doc.n} returned in ${doc.millis}ms`);
          logger.debug('db.perf.query', cursor.selector);
          logger.debug('db.perf.explain', doc);
        }
        stats = dbperf[collectionName] != null ? dbperf[collectionName] : dbperf[collectionName] = {
          total: 0,
          min: 0,
          max: 0,
          count: 0,
          collection: collectionName
        };
        stats.min = Math.min(stats.min, doc.millis);
        stats.max = Math.max(stats.max, doc.millis);
        stats.total += doc.millis;
        stats.count += 1;
        agg = dbperf.aggregate != null ? dbperf.aggregate : dbperf.aggregate = {
          total: 0,
          min: 0,
          max: 0,
          count: 0,
          collection: 'aggregate'
        };
        agg.min = Math.min(agg.min, doc.millis);
        agg.max = Math.max(agg.max, doc.millis);
        agg.total += doc.millis;
        return agg.count += 1;
      }
    });
  }

  dumpPerf() { // Not doing it for now
    var allStats, coll, now, stats;
    return;
    now = new Date();
    allStats = (function() {
      var results;
      results = [];
      for (coll in dbperf) {
        stats = dbperf[coll];
        results.push(_.extend(stats, {
          timestamp: now
        }));
      }
      return results;
    })();
    return db.dbperf.insert(allStats, function(err, inserted) {
      if (err) {
        return console.error('db.dumpPerf', err);
      } else if (inserted) {
        return dbperf = {};
      }
    });
  }

  history(hrs = 24, collection = 'aggregate', fn) {
    return Seq().seq(function() {
      return db.dbperf.find({
        collection: collection,
        timestamp: {
          $gt: new Date(Date.now() - hrs * 60 * 60 * 1000)
        }
      }, this);
    }).seq(function(cursor) {
      return cursor.toArray(fn);
    }).catch(function(err) {
      return fn(err);
    });
  }

};

module.exports = new DB();
